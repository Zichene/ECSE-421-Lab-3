#include <LiquidCrystal.h>

#include <PinChangeInterrupt.h>
#include <PinChangeInterruptBoards.h>
#include <PinChangeInterruptPins.h>
#include <PinChangeInterruptSettings.h>

/* pin setup for LCD */
LiquidCrystal lcd(2,3,4,5,6,7);

#define JOYSTICK_SW_PIN 9
#define JOYSTICK_VRX_PIN A0
#define JOYSTICK_VRY_PIN A1
#define TIM1_OCR_VAL_DEFAULT 2000 //  1m * 16M / 8

/* joystick thresholds */
#define LEFT_THRESHOLD  800 // more than this will be registered as left
#define RIGHT_THRESHOLD 400 // less than this will be registered as right
#define UP_THRESHOLD    400 // less than this will be registered as up
#define DOWN_THRESHOLD  800 // more than this will be registered as down

#define NUM_SYMBOLS 10 // number of symbols displayed in a game before end

typedef enum _direction_t {
  LEFT = 0,
  RIGHT = 1,
  UP = 2,
  DOWN = 3,
  BUTTON = 4,
  NONE = 5,
} direction_t;

volatile unsigned long globalMs = 0; // keeping track of number of ms passed since last 
volatile bool timerStarted = false; // keeping track of if the timer is started or not
volatile bool gameStarted = false; // keeping track of if the game has started
volatile bool gameRunning = false; // keeping track of if the game is currently running
volatile direction_t lastDirectionPressed = NONE; // last direction pressed
volatile direction_t lastDirGenerated = NONE; // last direction generated by the game
volatile bool currentlyInDelay = false;
volatile bool errorDetected = false;
volatile bool joystickChange = false;

unsigned long errorCount = 0; // count the number of errors during the game
//double reactionTimes[NUM_SYMBOLS]; // array to keep track of the reaction times (in ms)
double totalReactionTime = 0; // sum up the reaction times
//direction_t directions[NUM_SYMBOLS] = {LEFT, DOWN, BUTTON, RIGHT, UP, LEFT, DOWN, UP, RIGHT, BUTTON};

/********************************************
DRIVER CODE FOR SETMODE
*********************************************/
#define CLEAR_BIT(x,n) x &= ~(1 << n)
#define MCUCR_PUDBIT_OFFSET 4 // from https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf

typedef enum _GPIO_PORT_t {
  GPIO_PORT_B, // digital pin 8-13
  GPIO_PORT_C, // analog pins 
  GPIO_PORT_D  // digital pins 0-7
} GPIO_PORT_t;

typedef enum _GPIO_MODE_t {
  GPIO_MODE_INPUT = 0,
  GPIO_MODE_OUTPUT = 1,
  GPIO_MODE_INPUT_PULLUP = 2,
} GPIO_MODE_t;


GPIO_PORT_t getGpioPort(uint8_t pin) {
  if (pin >= 8 && pin <= 13) {
    return GPIO_PORT_B;
  } else if (pin >= 2 && pin <= 7) {
    return GPIO_PORT_D;
  }
  return GPIO_PORT_C;
}


void setPinMode(uint8_t pin, GPIO_MODE_t mode) {
  bool pullUp = false;
  if (mode == GPIO_MODE_INPUT_PULLUP) {
    /* need to disable the pullup disable bit in the MCUCR */
    CLEAR_BIT(MCUCR, MCUCR_PUDBIT_OFFSET);
    mode = 0; // this is for the i/o assignment with DDRx 
    pullUp = true;
  }

  switch (getGpioPort(pin)) {
    /* for each case, we need to set the correct mode using DDRx register (either input/output) and also PORTx register (for input pullup only) */
    case GPIO_PORT_B: 
    CLEAR_BIT(DDRB, pin-8);  /* port B pins start at pin 8 */
    DDRB |= (mode << pin-8); 
    PORTB |= (pullUp << pin-8);
    break;
    case GPIO_PORT_C: 
    CLEAR_BIT(DDRC, pin-14); /* port C pins start at pin 14 */
    DDRC |= (mode << pin-14); 
    PORTC |= (pullUp << pin-14);
    break;
    case GPIO_PORT_D: 
    CLEAR_BIT(DDRD, pin);  /* port D pins start at pin 0 */
    DDRD |= (mode << pin); 
    PORTD |= (pullUp << pin);
    //lcd.print("Here");
    break;
  }
}

direction_t getJoystickDirection() {
  int x_value = analogRead(JOYSTICK_VRX_PIN);
  int y_value = analogRead(JOYSTICK_VRY_PIN);

  if (y_value > LEFT_THRESHOLD) {
    return LEFT;
  }

  if (y_value < RIGHT_THRESHOLD) {
    return RIGHT;
  }

  if (x_value > DOWN_THRESHOLD) {
    return DOWN;
  }

  if (x_value < UP_THRESHOLD) {
    return UP;
  }
  return NONE;
}

void setup() {
  // put your setup code here, to run once:
  lcd.begin(16, 2);	// Set up the LCD's number of columns and rows:
  Serial.begin(57600);
  setPinMode(JOYSTICK_SW_PIN, GPIO_MODE_INPUT_PULLUP);
  //setPinMode(JOYSTICK_VRX_PIN, GPIO_MODE_INPUT_PULLUP);
  //setPinMode(JOYSTICK_VRY_PIN, GPIO_MODE_INPUT_PULLUP);
  attachPCINT(digitalPinToPCINT(JOYSTICK_SW_PIN), handleButton, FALLING);
  //attachPCINT(digitalPinToPCINT(JOYSTICK_VRX_PIN), handleVrX, CHANGE);
  //attachPCINT(digitalPinToPCINT(JOYSTICK_VRY_PIN), handleVrY, CHANGE);
  stopTimer();
  timerStarted = false;
}


void loop() {

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Press button to");
  lcd.setCursor(0, 1);
  lcd.print("  start game!");
  delay(1000);

  while (gameRunning) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Game has started!");

    for (int i = 0; i < NUM_SYMBOLS; i++) {
      // get random direction 
      direction_t dir = random(0, 5);;

      /* generate random delay 2-4 seconds */
      uint16_t randomDelayMS = random(2000, 4000);
      currentlyInDelay = true;
      delay(randomDelayMS);
      currentlyInDelay = false;

      // print out
      lcd.clear(); 
      switch (dir) {
        case LEFT:
        lcd.print("       <=");
        break;
        case RIGHT:
        lcd.print("       =>");
        break;
        case UP:
        lcd.print("       ^");
        break;
        case DOWN:
        lcd.print("       v");
        break;
        case BUTTON:
        lcd.print("       +");
        break;
      }
      startTimer();
      
      while (true) {
        direction_t userEntered = getJoystickDirection();
        //lcd.print(userEntered);
        if (userEntered != NONE) {
          if (userEntered == dir) {
            break;
          } else if (lastDirectionPressed != userEntered) {
            errorCount++;
          }
          lastDirectionPressed = userEntered;
        }
        if (lastDirectionPressed == BUTTON && lastDirectionPressed == dir) {
          break;
        }
      }
      // joystickChange = false;
      // while (true) {  
      //   if (joystickChange) {
      //    if (lastDirectionPressed == dir) {
      //      joystickChange = false;
      //      break;
      //    }
      //     if (lastDirectionPressed != dir) {
      //     // wrong answer
      //     errorCount++;
      //     joystickChange = false;
      //     continue;
      //    }
      //   }
      // }
      lcd.clear(); // clear screen to indicate that successful 
      totalReactionTime += stopTimer();
      joystickChange = false;
      lastDirectionPressed = NONE;
      lastDirGenerated = dir;
    }
    lcd.clear();
    lcd.print("Game over.");
    delay(3000);

    lcd.setCursor(0, 0);
    lcd.print("Number of errors: ");
    lcd.setCursor(0, 1);
    lcd.print(errorCount);
    delay(5000);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Total time (s): ");
    lcd.setCursor(0, 1);
    lcd.print(totalReactionTime/1000);
    delay(5000);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Avg time per trial (s): ");
    lcd.setCursor(0, 1);
    lcd.print(totalReactionTime/(1000*NUM_SYMBOLS));
    delay(5000);

    gameRunning = false;
    errorCount = 0;
    totalReactionTime = 0;
  }
}

void handleButton() {
  if (!gameRunning) {
    gameRunning = true;
  } else if (!joystickChange && !currentlyInDelay) {
    //lcd.print("Button");
    lastDirectionPressed = BUTTON;
    joystickChange = true;
  }
}

void handleVrX() {
  int x_value = analogRead(JOYSTICK_VRX_PIN);
  // Serial.print("VrX: ");
  // Serial.print(x_value);
  if (x_value > DOWN_THRESHOLD && !currentlyInDelay && lastDirectionPressed != BUTTON) {
    lcd.print(" Down");
    lastDirectionPressed = DOWN;
    //if (errorDetected) errorDetected = false;
    joystickChange = true;
  }
  if (x_value < UP_THRESHOLD && !currentlyInDelay && lastDirectionPressed != BUTTON) {
    lcd.print(" Up");
    lastDirectionPressed = UP;
    //if (errorDetected) errorDetected = false;
    joystickChange = true;
  }
}

void handleVrY() {
  int y_value = analogRead(JOYSTICK_VRY_PIN);
  // Serial.print("VrY: ");
  // Serial.print(y_value);
  if (y_value > LEFT_THRESHOLD && !currentlyInDelay && lastDirectionPressed != BUTTON) {
    lcd.print(" Left");
    lastDirectionPressed = LEFT;
    //if (errorDetected) errorDetected = false;
    joystickChange = true;
  }
  if (y_value < RIGHT_THRESHOLD && !currentlyInDelay && lastDirectionPressed != BUTTON) {
    lcd.print(" Right");
    lastDirectionPressed = RIGHT;
    //if (errorDetected) errorDetected = false;
    joystickChange = true;
  }
}

void changeOCR1(uint16_t OCR1val) {
  /* change value of OCR1A */
  OCR1A = OCR1val;
}

/* initialize the timer so that it triggers an interrupt at every 1 ms  */
void startTimer() {
  cli(); //stop all interrupts
  // turn on CTC mode
  TCCR1A = 0;
  TCCR1B = 0;
  TCCR1B |= (1 << WGM12);

  // Set CS12 bit for prescaler 8
  TCCR1B |= (1 << CS11); 
  
  //initialize counter value to 0;
  TCNT1  = 0;
  
  // set timer count: OCR = 1 ms * 16 MHz/8 = 2000
  OCR1A = TIM1_OCR_VAL_DEFAULT;

  // enable timer compare interrupt
  TIMSK1 |= (1 << OCIE1A);

  sei();//allow interrupts
  timerStarted = true;
}

/* stop timer and return time passed as a double, reset the globalMs value */
double stopTimer() {
  double retval = globalMs + ((double)TCNT1)/TIM1_OCR_VAL_DEFAULT;
  cli();

  TCCR1B &= ~(1<< CS12);  // turn off the clock altogether
  TCCR1B &= ~(1<< CS11);
  TCCR1B &= ~(1<< CS10);

  sei();
  globalMs = 0; // reset globalMs
  timerStarted = false;
  return retval;
}

/* Timer ISR */
ISR(TIMER1_COMPA_vect) {
 // increment number of ms passed
 // lcd.print(globalMs);
  globalMs++;
}





